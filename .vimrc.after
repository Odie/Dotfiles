"=====[ Source everything from individual settings files ]=============
"for f in split(glob('~/vimfiles/vimrc.d/*.vim'), '\n')
"	exe 'source' f
"endfor

"Basic Settings=================================================={{{

set relativenumber
set number

"=====[ Color Scheme ]=============
"color molokai
color wombat256

"=====[ Font ]=============
" Setup font for MacVim
if has('gui_running')
	set guifont=Anonymous\ Pro\ for\ Powerline:h14
	set columns=999    " create windows with maximum width by default
  set lines=999      " create windows with maximum height by default
endif

"=====[ Sane tab settings for vim ]=============
set noexpandtab
set copyindent
set preserveindent
set softtabstop=0
set shiftwidth=2
set tabstop=2
augroup detect_indent
	autocmd!
	autocmd BufReadPost * :DetectIndent
	let g:detectindent_preferred_indent = 2
augroup END

"=====[ Enable clipboard in terminal ]=============
if ! has('gui_running')
	set clipboard=unnamed
endif

set cursorline  " highlight current line
set autoread    " Reload file when modified

"=====[ Discard changed buffers by default ]=============
set hidden


"=====[ Remove Search Highlighting on esc key ]=============
if has('gui')
  nnoremap <silent> <esc> :nohlsearch<return><esc>
else
	augroup no_highlight
		autocmd!
		autocmd TermResponse * nnoremap <esc> :noh<return><esc>
	augroup END
endif

"=====[ Disable bells ]=============
set noerrorbells visualbell t_vb=
autocmd GUIEnter * set visualbell t_vb=

set ttyfast
set lazyredraw

"=====[ Centrally stored swp files ]=============
"Commented because Janus already does this. This is kept here in case we
" need a vimrc without using Janus
set nobackup
"set backupdir=~/.vim.backup/backup
"set directory=~/.vim.backup/tmp

"==================================================================}}}

"[FileType-specific Settings]======================================{{{
"=====[ Remove Trailing white spaces ]=============
augroup no_trailing_spaces_pre
	" By default, trailing spaces will be trimmed for all file types.
	" Space trimming will be applied at BufRead and BufWrite.
	" This can be disabled on a buffer to buffer basis by setting
	" b:trim_trailing_spaces = 0
	autocmd!
	autocmd BufNewFile,BufRead * let b:trim_trailing_spaces=1
augroup END

augroup filetype_vim
	autocmd!
	autocmd FileType vim setlocal foldmethod=marker
augroup END

augroup filetype_twig
	autocmd!
	autocmd FileType twig set syntax=html
augroup END

augroup filetype_haskell
	autocmd!
	autocmd FileType haskell set expandtab
augroup END

augroup filetype_markdown
	autocmd!
	autocmd FileType markdown let b:trim_trailing_spaces=0
	autocmd FileType markdown set list
	autocmd FileType markdown setlocal foldmethod=expr
	autocmd Filetype markdown setlocal foldexpr=OrderedListFold(v:lnum)

	" Search backwards for a line that starts with a number
	function! NextNumberHeading(lnum)
		let numlines = line('$')
		let current = a:lnum + 1

		while current <= numlines
			if getline(current) =~? '\v^\d+\.'
				return current
			endif

			let current += 1
		endwhile

		return -2
	endfunction

	function! IsNumberHeading(lnum)
		if getline(a:lnum) =~? '\v^\d+\.'
			return 1
		else
			return 0
		endif
	endfunction

	function! OrderedListFold(lnum)
		let current = a:lnum

		" We're interested in folding markdown that's being explicitly or
		" auto-numbered.
		" This means we're only interested in classifying lines into the
		" following categories:
		" 1. A number heading
		" 2. Not a number heading
		if IsNumberHeading(current+1)
			return 0
		else
			return 1
		endif
	endfunction
augroup end

augroup no_trailing_spaces_post
	autocmd!
	autocmd BufRead,BufWrite *
		\ if (! &bin) && b:trim_trailing_spaces |
		\		silent! %s/\s\+$//ge |
		\ endif
augroup END
"==================================================================}}}

"[Plugin Settings]======================================{{{

"=====[ Powerline Settings ]=============
" Immediately reflect mode changes
if ! has('gui_running')
	set ttimeoutlen=10
	augroup FastEscape
	autocmd!
		au InsertEnter * set timeoutlen=0
		au InsertLeave * set timeoutlen=1000
	augroup END
endif

set laststatus=2		" Always show statusline
set t_Co=256			" Use 256 colours (Use this setting only if your terminal supports 256 colours)
set noshowmode			" Hide the default mode text (e.g. -- INSERT -- below the statusline)
set encoding=utf-8		" make sure we can display fancy characters correctly

"=====[ Unite configuartion ]=============
" Use ag if available
if executable('ag')
	let g:unite_source_grep_command = 'ag'
	let g:unite_source_grep_default_opts = '--nogroup --nocolor --column'
	let g:unite_source_grep_recursive_opt = ''
endif

call unite#custom#source('file_rec', 'ignore_pattern', '/.png$/')
let g:unite_enable_start_insert = 1
let g:unite_winheight = 10
let g:unite_split_rule = 'botright'
let g:unite_prompt = '>>> '
let g:unite_source_history_yank_enable = 1
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
"nnoremap <C-p> :Unite file_rec/async<CR>
"nnoremap <C-i> :Unite -buffer-name=files	file<cr>
nnoremap <leader>r :Unite -buffer-name=mru		 file_mru<cr>
nnoremap <leader>o :Unite -buffer-name=outline outline<cr>
nnoremap <leader>y :Unite -buffer-name=yank		 history/yank<cr>
nnoremap <leader>b :Unite -buffer-name=buffer -quick-match buffer<cr>

" Custom mappings for the unite buffer
autocmd FileType unite call s:unite_settings()
function! s:unite_settings()
	" Play nice with supertab
	let b:SuperTabDisabled=1
	nmap <buffer> <ESC>		 <Plug>(unite_exit)
	" Enable navigation with control-j and control-k in insert mode
	imap <buffer> <C-j>	<Plug>(unite_select_next_line)
	imap <buffer> <C-k>	<Plug>(unite_select_previous_line)
endfunction

"==================================================================}}}

"[Custom functions]================================================{{{

"=====[ Highlight the match in red ]=============
function! HLNext (totalBlinkTime)
	highlight WhiteOnRed ctermfg=white ctermbg=red guibg=darkred guifg=white
	let [bufnum, lnum, col, off] = getpos('.')
	let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
	let target_pat = '\c\%#'.@/

	let blinkCount = 1
	let blinkTime = a:totalBlinkTime/((blinkCount * 2) - 1)
	let i = 0
	while i < blinkCount
		let i += 1
		let ring = matchadd("WhiteOnRed", target_pat, 101)
		redraw
		exec 'sleep ' . float2nr(blinkTime * 1000) . 'm'
		call matchdelete(ring)
		redraw
		if i < blinkCount
			exec 'sleep ' . float2nr(blinkTime * 1000) . 'm'
		endif
	endwhile
endfunction

" trim trailing whitespace in the current file
function! RTrim()
  %s/\v\s+$//e
  noh
endfunction

"==================================================================}}}

"[Mappings]=========================================================={{{

"=====[ Faster ':' commands ]=============
nnoremap ; :
nnoremap : ;

map <C-H> <C-W>h
map <C-J> <C-W>j
map <C-K> <C-W>k
map <C-L> <C-W>l<C-W>_
nnoremap <leader>p :set invpaste paste?<CR>

"=====[ Setup key mappings ]=============
:nnoremap <leader>ev :vsplit ~/.vimrc.after<cr>
:nnoremap <leader>sv :source ~/.vimrc.after<cr>:echom "Sourced vimrc"<cr>

"=====[ Highlight matches when jumping to next ]=============
nnoremap <silent> n n:call HLNext(0.2)<cr>
nnoremap <silent> N N:call HLNext(0.2)<cr>

"=====[ Setup movement mappings ]=============
"" Select contents of next or last ()
:onoremap in( :<c-u>normal! f(vi(<cr>
:onoremap il( :<c-u>normal! F)vi(<cr>

"==================================================================}}}
